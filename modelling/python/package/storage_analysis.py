import sys, os
print("Operating system: %s" %sys.platform)
if sys.platform == 'win32':
    curr_path = 'c:\\Nextcloud\\Thermal Battery Research\\modelling\\python'
elif sys.platform == 'linux':
    curr_path = '/home/jeff/cloud/documents/work/ANU/Thermal Battery Research/modelling/python'
else: print("What operating system are you running?! I've never even heard of %s" %sys.platform)
if curr_path not in sys.path:
    sys.path.append(curr_path)
    print('Path added! \n')
os.chdir(curr_path)
print("Working directory is now %s" %curr_path)
import numpy as np
import pandas as pd
from projdirs import datadir, figdir, resultsdir, paperdir
import matplotlib.pyplot as plt
import package.sql_manager as sm
from datetime import timedelta, time
import package.get_NEM_data as gd
import package.optimisation as op
from calendar import monthrange
import datetime
import pdb

def compare_storage(FS, State, Year, SH, RTE, Cap, Loss, Month1=1, Month2=12):
      """This function compares the charging and discharging profile of 
      a storage against the storage with erfect
      foresight.
      FS: the type of foresight, either 'rolling' or 'daily'
      You can define the comparison window using Month1 and Month2.
      Month1: start of the comparison window e.g. 1
      Month2: end (excluding) of the comparison window e.g. 2
      """
      try:
            if FS not in ['rolling', 'daily']:
                  raise ValueError
      except ValueError:
            print("The storage type should be either 'rolling' or 'daily'")
            return
      comp_res = pd.DataFrame(columns=['FS', 'State','year', 'RTE','SV-PF','SV',
                                       'charge_acc', 'disch_acc'])
      time_stamp1 = pd.Timestamp(year = Year, month=Month1, day=1, hour=4)
      time_stamp2 = pd.Timestamp(year = Year, month=Month2,
                               day=monthrange(Year,Month2)[1],
                               hour=23, minute=59)
      
      # get the storage parameter generated by perfect foresight
      # this needs the optimisation function to run again
      results = op.calc_S_perfect_foresight(State, Year, RTE, SH, Loss, Cap)
      
      charge_perfect = pd.Series(results['Pin'])
      discharge_perfect = pd.Series(results['Pout'])
      Index = pd.date_range(pd.Timestamp(year=Year, month=1, day=1),
                            pd.Timestamp(year=Year, month=12, day=31, hour=23,
                                         minute=59), freq='30min')
      charge_perfect.index = Index
      discharge_perfect.index = Index
      baseline_charge = charge_perfect>0
      baseline_discharge = discharge_perfect>0
      #######################################
            
      if FS == 'rolling':
            # get storage parameters generated by 0.5-hourly rolling forecast
            cols_rolling = ['state','date_time', 'sh', 'rte', 'cap', 'loss', 'window',
                          'Pin', 'Pout', 'Q_start', 'Q_end', 'obj']
            DB = 'storage_value_rolling_forecast_%s.db'%(State)
            data_rolling = sm.get_data(cols_rolling,
                                 'storage_value', DB)
            data_rolling['date_time'] = pd.to_datetime(data_rolling['date_time'])
            data_rolling = data_rolling.set_index('date_time')
            data_rolling = data_rolling.sort_index()
             #######################################    
            storage_rolling = data_rolling[(data_rolling['state']==State)
                      & (data_rolling.index.year==Year)
                      & (data_rolling['rte']==RTE)]
            charge_rolling = storage_rolling['Pin']>0
            discharge_rolling  = storage_rolling['Pout']>0
            SV = storage_rolling['obj'].sum()
            #######################################
            comparison_rolling_charge = \
            (baseline_charge[charge_rolling.loc[ time_stamp1:time_stamp2].index]\
            == charge_rolling.loc[time_stamp1:time_stamp2]) & \
              (charge_rolling.loc[ time_stamp1:time_stamp2] == True)
            
            charge_accuracy = \
            comparison_rolling_charge.sum()/\
            charge_rolling.loc[ time_stamp1:time_stamp2].sum()

            comparison_rolling_discharge = \
            (baseline_discharge[discharge_rolling.loc[time_stamp1:time_stamp2].index]\
            == discharge_rolling.loc[time_stamp1:time_stamp2]) &\
             (discharge_rolling.loc[time_stamp1:time_stamp2]==True)
            
            discharge_accuracy =\
            comparison_rolling_discharge.sum()/\
            discharge_rolling.loc[time_stamp1:time_stamp2].sum()
            
      elif FS == 'daily':  
            # get the storage parameter for daily forecast
            DB = 'storage_value_daily_forecast_%s.db'%(State)            
            cols_daily = ['state','date_time', 'sh', 'rte', 'loss', 'cap',
                                'Pin', 'Pout', 'obj_forecast', 'obj_actual' ]
            data_daily = sm.get_data(cols_daily, 'storage_value', 
                                     DB)
            data_daily['date_time'] = pd.to_datetime(data_daily['date_time'])
            data_daily = data_daily.set_index('date_time')
            data_daily = data_daily.sort_index() 
            storage_daily = data_daily[(data_daily['state']==State)
                & (data_daily.index.year==Year)
                & (data_daily['rte']==RTE)]
            charge_daily = storage_daily['Pin']>0
            discharge_daily = storage_daily['Pout']>0
            SV = storage_daily['obj_actual'].sum()
            #######################################
            comparison_daily_charge = \
            (baseline_charge[charge_daily.loc[time_stamp1:time_stamp2].index]\
            == charge_daily.loc[time_stamp1:time_stamp2]) &\
             (charge_daily.loc[time_stamp1:time_stamp2]==True)
             
            
            charge_accuracy = \
            comparison_daily_charge.sum()/\
            charge_daily.loc[time_stamp1:time_stamp2].sum()

            comparison_daily_discharge = \
            (baseline_discharge[discharge_daily.loc[time_stamp1:time_stamp2].index]\
            == discharge_daily.loc[time_stamp1:time_stamp2]) &\
             (discharge_daily.loc[time_stamp1:time_stamp2]==True)
             
            
            discharge_accuracy = \
            comparison_daily_discharge.sum()/\
            discharge_daily.loc[time_stamp1:time_stamp2].sum()
            
 
      comp_res = pd.Series(
            [FS, State, Year, RTE, results['obj'], SV, charge_accuracy, 
             discharge_accuracy],    index=comp_res.columns)
      return(comp_res)
      print('Analysis completed for %d'%(Year))
      print('Completed!')
      
      
def monitor_storage(FS, State, Year, SH, RTE, Cap, Loss, Month1=1, Month2=12):
    """This function plots the charging and discharing profile of the battery 
    for rolling and daily forecast cases"""
    
    try:
            if FS not in ['rolling', 'daily']:
                  raise ValueError
    except ValueError:
        print("The storage type should be either 'rolling' or 'daily'")
        return
    
    results = op.calc_S_perfect_foresight(State, Year, RTE, SH, Loss, Cap)        
    storage_perfect = pd.DataFrame({'Pin': results['Pin'],
                                   'Pout': results['Pout']})
    
    Index = pd.date_range(pd.Timestamp(year=Year, month=1, day=1),
                          pd.Timestamp(year=Year, month=12, day=31, hour=23,
                                       minute=59), freq='30min')
    storage_perfect.index = Index
    
    if FS == 'rolling':
        # get storage parameters generated by 0.5-hourly rolling forecast
        cols_rolling = ['state','date_time', 'sh', 'rte', 'cap', 'loss', 'window',
                      'Pin', 'Pout', 'Q_start', 'Q_end', 'obj']
        DB = 'storage_value_rolling_forecast_%s.db'%(State)
        data_rolling = sm.get_data(cols_rolling,
                             'storage_value', DB)
        data_rolling['date_time'] = pd.to_datetime(data_rolling['date_time'])
        data_rolling = data_rolling.set_index('date_time')
        data_rolling = data_rolling.sort_index()
         #######################################    
        storage = data_rolling[(data_rolling['state']==State)
                  & (data_rolling.index.year==Year)
                  & (data_rolling['rte']==RTE)]
    elif FS == 'daily':  
        # get the storage parameter for daily forecast
        DB = 'storage_value_daily_forecast_%s.db'%(State)            
        cols_daily = ['state','date_time', 'sh', 'rte', 'loss', 'cap',
                            'Pin', 'Pout', 'obj_forecast', 'obj_actual' ]
        data_daily = sm.get_data(cols_daily, 'storage_value', 
                                 DB)
        data_daily['date_time'] = pd.to_datetime(data_daily['date_time'])
        data_daily = data_daily.set_index('date_time')
        data_daily = data_daily.sort_index() 
        storage = data_daily[(data_daily['state']==State)
            & (data_daily.index.year==Year)
            & (data_daily['rte']==RTE)]
    
    #Start plotting
    font_size = 16
    fig1 = plt.figure(figsize=(8, 5))
    ax1 = fig1.add_subplot(111)
    ax1.set_ylabel('MWe', color='k')   
    ax1.tick_params(axis="y", labelsize=font_size)    
    plt.title('Region=%s, Foresight=%s, RTE=%d%%'
              % (State, FS.capitalize(), RTE), fontsize=font_size)
    plt.grid()
    
    plt.step(storage.index, storage['Pin'], 'b', label='Charging')
    plt.step(storage_perfect.index, storage_perfect['Pin'], 'r', 
             label='Charging_perfect')
    plt.legend(loc='upper left', fontsize=font_size-2)
    plt.rcParams["legend.edgecolor"] = 'k'
    ax2 = ax1.twinx()
    rrp_actual = gd.load_rrp_cal(Year,State)
    ax2.plot(rrp_actual.index, rrp_actual, 'k')
    #ax2.set_ylim([-100,300])    
    ax2.set_ylabel('RRP ($/MWh)', color='k')
    
    fig2 = plt.figure(figsize=(8, 5))
    ax3 = fig2.add_subplot(111)
    plt.title('Region=%s, Foresight=%s, RTE=%d%%'
              % (State, FS.capitalize(), RTE), fontsize=font_size)
    plt.grid()
    plt.step(storage.index, storage['Pout'], 'b', label='Discharging')
    plt.step(storage_perfect.index, storage_perfect['Pout'], 'r', 
             label='Discharging_perfect')
    plt.legend(loc='upper left', fontsize=font_size-2)
    plt.rcParams["legend.edgecolor"] = 'k'
    ax4 = ax3.twinx()
    ax4.plot(rrp_actual.index, rrp_actual, 'k')
    #ax4.set_ylim([-100,300])
    ax4.set_ylabel('RRP ($/MWh)', color='k')    
    ax3.set_ylabel('MWe', color='k')
    ax3.tick_params(axis="y", labelsize=font_size)
    plt.show()
    

def cash_flow(Storage,Year, RTE, State):
      storage = Storage[
                  (Storage['date_time'].dt.year==Year) &
                  (Storage['rte']==RTE) &
                  (Storage['state']==State)]
      
      storage = storage.set_index('date_time')
      rrp = gd.load_rrp_cal(Year, State)
      storage['rrp'] = rrp[storage.index]
      storage['chash_flow'] = (storage.Pout-storage.Pin)*storage.rrp*0.5
      storage['revenue'] = storage[storage.chash_flow>0]['chash_flow']
      storage['expense'] = storage[storage.chash_flow<0]['chash_flow']
      return(storage.fillna(0))
      
      

def analyse_revenue(State,Year,RTE):
      #load the perfect battery data
      db = 'storage_value_perfect_%s.db'%(State); table = 'storage_value'
      cols = [x[0] for x in sm.list_columns(db,table)]; 
      Storage_Perf = sm.get_data(cols,table, db)
      Storage_Perf['date_time'] = pd.to_datetime(Storage_Perf['date_time'])
      
      # load the battery with daily optimisation
      db = 'storage_value_daily_forecast_%s.db'%(State);
      cols = [x[0] for x in sm.list_columns(db,table)]; 
      Storage_Daily = sm.get_data(cols,table, db)
      Storage_Daily['date_time'] = pd.to_datetime(Storage_Daily['date_time'])
      
      # load the battery with rolling forecast
      db = 'storage_value_rolling_forecast_%s.db'%(State);
      cols = cols = [x[0] for x in sm.list_columns(db,table)]; 
      Storage_Rolling = sm.get_data(cols,table, db)
      Storage_Rolling['date_time'] = pd.to_datetime(Storage_Rolling['date_time'])
      
      rrp_range = np.arange(-1000,14000,50)
      data = pd.DataFrame(columns = ['state','year','rte','rrp_range','frac_perf',
                                        'frac_daily','frac_rolling'])
      revenue = pd.DataFrame(columns = ['state','year','rte','rrp_range','frac_perf',
                                        'frac_daily','frac_rolling'])

      print(State,',', Year,',', RTE)
      storage_perf = cash_flow(Storage_Perf, Year, RTE, State)
      storage_daily = cash_flow(Storage_Daily, Year, RTE, State)
      storage_rolling = cash_flow(Storage_Rolling, Year, RTE, State)
      frac_perf = list([]);frac_daily = list([]);frac_rolling = list([])
      
      for rrp in rrp_range:
            frac_perf.append(storage_perf[storage_perf['rrp']<rrp]['revenue'].sum())
            frac_daily.append(storage_daily[storage_daily['rrp']<rrp]['revenue'].sum())
            frac_rolling.append(storage_rolling[storage_rolling['rrp']<rrp]['revenue'].sum())
      
      data['rrp_range']=rrp_range
      data['state']=State
      data['frac_perf']=frac_perf
      data['frac_daily']=frac_daily
      data['frac_rolling']=frac_rolling
      data['year']=Year
      data['rte']=RTE
      revenue = revenue.append(data, ignore_index=True)
      
      frac_perf = list([]);frac_daily = list([]);frac_rolling = list([])
      expense = pd.DataFrame(columns = ['state','rte','year','rrp_range','frac_perf',
                                  'frac_daily','frac_rolling'])
      for rrp in rrp_range:
            frac_perf.append(storage_perf[storage_perf['rrp']<rrp]['expense'].sum())
            frac_daily.append(storage_daily[storage_daily['rrp']<rrp]['expense'].sum())
            frac_rolling.append(storage_rolling[storage_rolling['rrp']<rrp]['expense'].sum())
      data['rrp_range']=rrp_range
      data['state']=State
      data['frac_perf']=frac_perf
      data['frac_daily']=frac_daily
      data['frac_rolling']=frac_rolling
      data['year']=Year
      data['rte']=RTE
      expense = expense.append(data, ignore_index=True)
      return(revenue,expense)



def revenue_dist(Region,Year,RTE):
      #load the perfect battery data
      
      db = 'storage_value_perfect_%s.db'%(Region);
      Storage_Perf = sm.get_data('N/A','N/A', db)
      Storage_Perf['date_time'] = pd.to_datetime(Storage_Perf.date_time)
      
      
      rrp_range = np.arange(-1000,3000,50)
      data = pd.DataFrame(columns = ['region','year','rte','rrp_range',
                                     'frac_perf'])
      revenue = pd.DataFrame(columns = ['region','year','rte','rrp_range',
                                        'frac_perf'])

      print(Region,',', Year,',', RTE)
      storage_perf = cash_flow(Storage_Perf, Year, RTE, Region)
      frac_perf = list([])
      
      for rrp in rrp_range:
            frac_perf.append(storage_perf[storage_perf['rrp']<rrp]['revenue'].sum())
            
      
      data['rrp_range']=rrp_range
      data['state']=Region
      data['frac_perf']=frac_perf
      data['year']=Year
      data['rte']=RTE
      revenue = revenue.append(data, ignore_index=True)
      
      frac_perf = list([])
      expense = pd.DataFrame(columns = ['state','rte','year','rrp_range',
                                        'frac_perf'])
      for rrp in rrp_range:
            frac_perf.append(storage_perf[storage_perf['rrp']<rrp]['expense'].sum())
            
      data['rrp_range']=rrp_range
      data['state']=Region
      data['frac_perf']=frac_perf
      data['year']=Year
      data['rte']=RTE
      expense = expense.append(data, ignore_index=True)
      return(revenue,expense)
      
      
      
            
def MASE(State, Year, Cap):
    """
    This function calculates the Mean Average Scaled Error of forecast prices
    for each year.
    State: a NEM state
    Year: e.g. 2018
    Cap: sets an upper bound for rrp and foreecast prices to crop the outliers
    """
    month_abre = [datetime.date(Year, i, 1).strftime('%b') for i in np.arange(1,13,1)]
    MASE = pd.DataFrame(
    columns=['state','year', 'cap', 'hour']+month_abre)
    for m,Month in enumerate(np.arange(1,13,1)):
        price_pre = gd.load_rrp_forecast_monthly(State,Year,Month)
        price_spot = gd.load_rrp_cal_stamped(Year, State)
        for h, Hour in enumerate(np.arange(0,24,1)):
            
            point1 = pd.Timestamp(year=Year, month=Month, day = 1, hour=Hour)
            point2 = pd.Timestamp(year=Year, month=Month, day = monthrange(Year,Month)[1])
    
            time_gen = pd.date_range(point1,point2,freq='24H')
            rrp = pd.DataFrame(columns=['state', 'generated', 'rrp_fc','rrp_ac'])
            for Time in time_gen:
                rrp_fc = price_pre[price_pre.generated==Time].sort_values('date_time')
                if rrp_fc .empty:
                      continue
                rrp_fc = rrp_fc.set_index('date_time').loc[Time:Time+timedelta(days=1)] # crop the forecast data to 24 hrs
                rrp_fc.columns=['state','generated','rrp_fc']
                rrp_ac = price_spot.set_index('date_time').loc[rrp_fc.index].drop('region',axis=1)
                rrp_ac.columns = ['rrp_ac']
                rrp = rrp.append(pd.concat([rrp_fc,rrp_ac],axis=1))
                rrp.loc[rrp.rrp_fc>Cap, 'rrp_fc'] = Cap
                rrp.loc[rrp.rrp_ac>Cap, 'rrp_ac'] = Cap
                
            denominator = 0
            numerator = 0 
            control=0
            T_m = 0
            for t,Time in enumerate(time_gen[:-1]):
                if t>2:
                    #print(Time)                    
                    pdb.set_trace()
                    control +=1
                    T_m += len(rrp.loc[time_gen[t]+timedelta(hours=0.5):time_gen[t+1]-timedelta(hours=0.5)]['rrp_ac'].values)
                    denominator += abs(
                    rrp.loc[time_gen[t]+timedelta(hours=0.5):time_gen[t+1]-timedelta(hours=0.5)]['rrp_ac'].values-
                    rrp.loc[time_gen[t-1]+timedelta(hours=0.5):time_gen[t]-timedelta(hours=0.5)]['rrp_ac'].values).sum()
    
            numerator = abs(rrp.rrp_fc-rrp.rrp_ac).sum() 
            denominator = denominator/T_m
            numerator = numerator/len(rrp.rrp_fc)
            print(State,Month,Hour)
            MASE.set_value(h, month_abre[m], numerator/denominator)
            MASE.set_value(h, 'state', State)
            MASE.set_value(h, 'year', Year)
            MASE.set_value(h, 'hour', Hour)
            MASE.set_value(h, 'cap', Cap)
            
    return(MASE)
    


def operation_distribution(profile):
      """
      This function the length of the the contineous charging or discharging 
      for a storage.
      profile is the timeseries of charging or deischarging with the index of 
      dat_time
      """
      DATA = profile.tolist()
      counter=0
      result=[]
      for i in np.arange(0,len(DATA)):
            if DATA[i]>0.01:
                  counter+=1
                  if i==len(DATA)-1:
                        result.extend([counter])
            elif not(counter==0):
                  result.extend([counter])
                  counter=0
      return(result)
