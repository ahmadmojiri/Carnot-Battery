#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Feb 25 21:06:01 2020

@author: jeff
"""


from subprocess import check_output
from projdirs import optdir, datadir
from .make_dzn_file_PV_plant_SH_PB import make_dzn_file_PV_plant_SH_PB
import sql_manager as sm
from numpy import array, ceil, zeros
import package.get_NEM_data as gd
import sys
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import requests

pd.plotting.register_matplotlib_converters()

win = sys.platform == 'win32'
connector = ['/','\\'][win]

class Simulation():
    """This is the calss that brings all the variables together and creates
    the minzinc file for optimisation, returning results that can be plotted
    and investigated."""
    
    ##Things to do:
    # * Allow for all the time series to be resampled at interval 'dt', with 
    #   a specific interpolation technique.
    
    def __init__(self, Time, Financials, Market, Tank, PowerCycle, 
                 Plant = None, Inverter = None):
        self.Time = Time
        self.Financials = Financials
        self.Market = Market
        self.Plant = Plant
        self.Tank = Tank
        self.Inverter = Inverter
        self.PowerCycle = PowerCycle

        self.c = Market.load_rrp(Time.start_time, Time.end_time, Plant.region)
        
        if Plant:
            self._resample_DC_time_series()
            self.P_inv_in_max = Plant.power_AC / Inverter.eta_inv
        else: self.no_solar = True
        
        if Tank.opt_rh:
            self.c_rh = Financials.calc_annual_cost(Tank.C_rh) * \
                Financials.USD2AUD * Time.yearfrac
        
        if Tank.opt_ts: 
            self.c_ts = Financials.calc_annual_cost(Tank.C_ts) * \
                Financials.USD2AUD * Time.yearfrac
                
        if PowerCycle.opt_pc:
            self.c_pc = Financials.calc_annual_cost(PowerCycle.C_pc) * \
                Financials.USD2AUD * Time.yearfrac
                
        #from NREL annual technology baseline spreadsheet https://atb.nrel.gov/
        #$1111/kW installed plus $20/(kW-yr) O&M cost
        self.c_pv = (Financials.calc_annual_cost(Plant.C_pv_cap) * Financials.USD2AUD + \
                     Plant.C_pv_OM * Financials.USD2AUD) * Time.yearfrac

        
    def _make_mzn_file(self):         
        
        ts_optstrs = ['float: c_ts;', 'var ', ' - c_ts * Q_ts_max', 
                            ' ++ [";"] ++  [show(Q_ts_max)]']
        if not self.Tank.opt_ts: ts_optstrs = [''] * len(ts_optstrs)
            
        
        rh_optstrs = ['float: c_rh;', 'var ', ' - c_rh * P_ts_in_max', 
                            ' ++ [";"] ++ [show(P_ts_in_max)]']
        if not self.Tank.opt_rh: rh_optstrs = [''] * len(rh_optstrs)
        
        pc_optstrs = ['float: c_pc;', 'var ', ' - c_pc * P_pc_out_max', 
                          ' ++ [";"] ++ [show(P_pc_out_max)]']
        if not self.Powercycle.opt_pc: pc_optstrs = [''] * len(pc_optstrs)
        
        
        
        plant_strs = ['float: eta_inv;',
                      'float: P_inv_in_max;  %%maximum power to the inverter (MW-e)]',
                      'array[tint] of float: P_in_panels;  %%DC electricity generated by the PV plant',
                      'array[tint] of var float: P_out_pass;  %%power lost due to full tank',
                      'array[tint] of var float: P_inv_in;     %%power into the inverter (MW-e)',
                      'constraint forall(i in tint)(P_out_pass[i] >= 0);',
                      'constraint forall(i in tint)(P_inv_in[i] >= 0);',
                      'constraint forall(i in tint)(P_inv_in[i] <= P_inv_in_max);',
                      'P_out_pass[i] + P_inv_in[i] - P_in_panels[i] + ',
                      ' + P_inv_in[i] * eta_inv',
                      ' ++ [";"] ++ [show(P_out_pass)] ++ [";"] ++ [show(P_inv_in)]']
        
        if not self.Plant: plant_strs = [''] * len(plant_strs)
        
        self.mzn_string = """
        int: N;
        
        set of int: tsamp = 1..N+1;    %%number of sample points
        set of int: tint = 1..N;       %%number of intervals
        
        float: dt;                %%time difference between sample points (also, interval length) (h)
        float: eta_rh;            %%efficiency of resistance heater in tank
        float: eta_pc;            %%efficiency of heat to electricity (power cycle efficiency)
        %s
        %s
        %s
        %s
        %s
        %sfloat: Q_ts_max;          %%maximum stored energy (MWh-th)
        %sfloat: P_ts_in_max;       %%maximum power to storage (MW-e)
        %sfloat: P_pc_out_max;
        
        var float: Q_ts_min;          %%minimum stored energy (MWh-th)
        var float: Q_ts_init;         %%initial stored energy (MWh-th)
        
        array[tint] of float: c;                 %%energy spot price
        %s
        
        %%flows into and out of the system (plus P_in_panels)
        
        array[tint] of var float: P_in_grid;    %%power purchased from the electricity grid (MW-e)
        array[tint] of var float: P_out_grid;   %%total power generated (MW-e)     
        %s
        
        %%flows within the system
        array[tint] of var float: P_ts_in;      %%power into the thermal energy storage (MW-e)
        array[tint] of var float: P_pc_out;     %%power out of the thermal energy storage tank (MW-e)
        %s
        array[tsamp] of var float: Q;        %%Energy in storage (MWh-th)
        
        var float: obj;
        
        obj = sum(i in tint)(c[i] * (P_out_grid[i] - P_in_grid[i]))%s%s%s;       
        
        %%=== CONSTRAINTS ===
        constraint Q[1] = Q_ts_init;
        
        %%"minimum" constraints
        constraint forall(i in tint)(P_in_grid[i] >= 0);
        constraint forall(i in tint)(P_out_grid[i] >= 0);
        %s
        constraint forall(i in tint)(P_ts_in[i] >= 0);
        constraint forall(i in tint)(P_pc_out[i] >= 0);
        %s
        constraint forall(i in tsamp)(Q[i] >= Q_ts_min);
        constraint P_ts_in_max > 0;
        constraint P_pc_out_max > 0;
        constraint Q_ts_max > 0;
        
        %%"maximum" constraints
        constraint forall(i in tint)(P_ts_in[i] <= P_ts_in_max);
        constraint forall(i in tint)(P_pc_out[i] <= P_pc_out_max);
        %s
        constraint forall(i in tsamp)(Q[i] <= Q_ts_max);
        constraint P_ts_in_max < 1e5;
        constraint P_pc_out_max < 1e5;
        constraint Q_ts_max < 1e5;
        
        %%energy balances
        constraint forall(i in tint)(P_in_grid[i] = %sP_ts_in[i]);
        constraint forall(i in tint)(P_out_grid[i] = P_pc_out[i]%s);
        constraint forall(i in tint)(Q[i+1] = Q[i] + (P_ts_in[i] * eta_rh - P_pc_out[i] / eta_pc) * dt);    
        
        solve maximize obj;
        
        output [show(P_in_grid)]%s ++ [";"] ++ [show(P_out_grid)] ++ [";"] ++ [show(Q)]%s%s%s;
        """%(plant_strs[0], ts_optstrs[0], rh_optstrs[0], pc_optstrs[0], plant_strs[1], ts_optstrs[1],
         rh_optstrs[1], pc_optstrs[1], plant_strs[2], plant_strs[3], plant_strs[4],
         ts_optstrs[2], rh_optstrs[2], pc_optstrs[2], plant_strs[5], plant_strs[6],
         plant_strs[7], plant_strs[8], plant_strs[9], plant_strs[10], ts_optstrs[3], 
         rh_optstrs[3], pc_optstrs[3])

        with open(optdir + 'general_optimisation.mzn', 'w') as text_file:
            text_file.write(self.mzn_string)   

            
    def _make_dzn_file(self):
        if self.Plant: 
            P_in_plant_str = 'P_in_plant = ' + np.array2string(np.array(self.Plant.DC_curtailed), 
                                    threshold = len(self.Plant.DC_curtailed) + 1,
                                    separator = ',', 
                                    formatter = {'float_kind' : lambda x: "%.3f" %x})
            eta_inv_str = 'eta_inv = %.2f;' %self.Plant.eta_inv
            P_inv_in_max_str = 'P_inv_in_max = %.2f;' %self.Plant.P_inv_in_max
        else: 
            P_in_plant_str = ''
            eta_inv_str = ''
            P_inv_in_max_str = ''
        
                
        if not self.Tank.opt_ts: 
            Q_ts_max_str = "Q_ts_max = %.8f;" %self.Tank.Q_ts_max
            c_ts_str = ''
        else: 
            Q_ts_max_str = ''
            c_ts_str = 'c_ts = %.2f;' %self.Tank.c_ts
        
        if not self.Tank.opt_rh: 
            P_ts_in_max_str = "P_ts_in_max = %.8f;" %self.Tank.P_ts_in_max
            c_rh_str = ''
        else: 
            P_ts_in_max_str = ''
            c_rh_str = 'c_rh = %.2f;' %self.Tank.c_rh
        
        if not self.PowerCycle.opt_pc: 
            P_pc_out_max_str = "P_pc_out_max = %.8f;" %self.PowerCycle.P_pc_out_max
            c_pc_str = ''
        else: 
            P_pc_out_max_str = ''
            c_pc_str = 'c_pc = %.2f;' %self.PowerCycle.c_pc
        
        
           
        self.dzn_string = """
        N = %i;
        
        dt = %.2f;      %%time difference between sample points (also, interval length) (h)
        
        eta_rh = %.2f;                      %%efficiency of electricity to heat
        eta_pc = %.2f;                     %%efficiency of heat to electricity
        %s
        
        %s
        Q_ts_min = 0;
        Q_ts_init = %.2f * Q_ts_max;              %%initial stored energy (MWh-th)
        
        %s
        %s
        %s               
                                 
        %s
        %s
        %s
        
        c = %s;                              %%Electricity spot price
        
        %s                                  %%DC flow from the PV plant
        
            """ %(self.Time.N, self.Time.dt, self.Tank.eta_rh, 
                  self.PowerCycle.eta_pc, eta_inv_str, Q_ts_max_str, 
                  self.Tank.Q_init_frac, P_ts_in_max_str, P_pc_out_max_str, 
                  P_inv_in_max_str, c_pc_str, c_ts_str, c_rh_str, 
                  str(list(self.c)), P_in_plant_str)
            
        with open(optdir + 'general_optimisation.dzn', 'w') as text_file:
            text_file.write(self.dzn_string)
    

    def optimise(write = True, db='storage_value_PV_perfect', table='storage_value'):
    
        plant.set_oversize(os)
##        plantsim = PlantPerf_PVW(plant)  " 
        plantsim = False
        plantsim.resample_DC_time_series(Year)
    
        cols_recording = ['plant_name', 'state', 'date_time', 'rte', 'os', 'Q_ts_max',
                          'c_pb', 'c_ts', 'P_ts_in_max', 'P_ts_out', 'P_ts_out_max',
                          'P_ts_in_panels_cur', 'P_ts_in_panels_vol', 
                          'P_ts_in_grid', 'P_out_pass', 'P_out_grid', 'RRP']
        
        idx = ['plant_name', 'state', 'date_time', 'rte', 'os', 'c_pb', 'c_ts']
          
        print(self.Plant.name, self.Plant.region, self.Plant.oversize, 
              self.PowerCycle.eta_pc, self.Time.start_time, self.Time.end_time)
          



        

        

        
        #DO IT!
        results = optimise(simparams)
                
        # register the generated data into the database
        if write:
              n = len(time_stamp_to_record)
              DATA = pd.DataFrame({'plant_name': plant.name,
                                   'state': State,
                                   'date_time':time_stamp_to_record,
                                   'rte': RTE,
                                   'os': os, 
                                   'c_pb': c_pb,
                                   'c_ts': c_ts,
                                   'P_ts_in_max': results['P_ts_in_max'],
                                   'P_ts_out_max': results['P_ts_out_max'],
                                   'Q_ts_max': results['Q_ts_max'],
                                   'P_ts_out': results['P_ts_out'][0:n],
                                   'P_ts_in_panels_cur': results['P_ts_in_panels_cur'][0:n], 
                                   'P_ts_in_panels_vol': results['P_ts_in_panels_vol'][0:n],
                                   'P_ts_in_grid': results['P_ts_in_grid'][0:n],
                                   'P_out_pass': results['P_out_pass'][0:n], 
                                   'P_out_grid': results['P_out_grid'][0:n],
                                   'RRP': c[0:n]
                                   })
              DB=db+'_%s.db'%(plant.name)
              sm.create_table(table, DB, cols_recording,
                              create_unique_idx=True, idx_cols=idx)
              sm.replace_into_db(DATA, DB, table, cols_recording)
              
        return(results)
    
    
    def optimise(simparams):
        """simparams is a dictionary containing the storage
        parameters for the dzn file."""    
        curdir =  optdir + "arbitrage%s" %['/', '\\'][windows]
        mzdir = ['/home/jeff/local/software/MiniZinc/bin/',
                 'C:\\Program Files\\minizinc\\'][windows]
        
        make_dzn_file_PV_plant_SH_PB(**simparams)
    
        output = str(check_output([mzdir + 'minizinc', "--soln-sep", '""', 
                                   "--search-complete-msg", '""', "--solver", 
                                   "COIN-BC", curdir + "arbitrage_PV_plant_SH_PB.mzn", 
                                   curdir + "arbitrage_PV_plant_SH_PB.dzn"]))
    
        output = output.replace("""\\r\\n""\\r\\n""\\r\\n\'""", '')
        output = output.replace("b\'[", '')
        output = output.replace('[', '')
        output = output.replace(']', '')
        
        if not windows: output = output.replace('\\n""\\n""\\n\'','')
    
        P_in_grid, P_out_pass, P_inv_in, P_out_grid, Q, Q_ts_max, P_ts_out_max, P_ts_in_max = \
            output.split(';')
        
        P_in_grid = array(P_in_grid.split(',')).astype(float)
        P_out_pass = array(P_out_pass.split(',')).astype(float)
        P_inv_in = array(P_inv_in.split(',')).astype(float)
        P_out_grid = array(P_out_grid.split(',')).astype(float)
        Q = array(Q.split(',')).astype(float)
        obj = sum((P_out_grid-P_in_grid) * simparams['c']) * simparams['dt']
        
        results = {}
        results['Q_ts_max'] = float(Q_ts_max)
        results['P_ts_in_max'] = float(P_ts_in_max)
        results['P_ts_out_max'] = float(P_ts_out_max)
        results['Q'] = Q
        results['P_in_plant'] = array(simparams['P_in_plant'])
        results['P_in_grid'] = P_in_grid
        results['P_out_grid'] = P_out_grid
        results['P_out_pass'] = P_out_pass
        results['P_inv_in'] = P_inv_in
        results['P_inv_out'] = P_inv_in * simparams['eta_inv']
        results['obj'] = obj
        results['eta_pc'] = simparams['eta_pc']
        results['eta_inv'] = simparams['eta_inv']
        results['eta_rh'] = simparams['eta_rh']
        results['eta_ts'] = simparams['eta_ts']    #possibly not implemented
        
            #calculate the equivalent electrical energy leaving the thermal battery
        results['P_ts_out'] = results['P_out_grid'] - results['P_inv_in'] * simparams['eta_inv']  #(MW-e)
        
        #calculate the electrical energy being used to charge the thermal battery
        results['P_ts_in'] = results['P_in_plant'] + results['P_in_grid'] - \
            results['P_out_pass'] - results['P_inv_in']
            
        results['P_ts_in_panels'] = results['P_ts_in'] - results['P_in_grid']
        
        P_ts_in_panels_cur = results['P_in_plant'] - simparams['P_inv_in_max'] - \
            results['P_out_pass']
        P_ts_in_panels_cur[P_ts_in_panels_cur < 0] = 0
        results['P_ts_in_panels_cur'] = P_ts_in_panels_cur
        
        results['P_ts_in_panels_vol'] = results['P_ts_in_panels'] - P_ts_in_panels_cur
        results['P_ts_in_grid'] = results['P_in_grid'] 
        results['timeindex'] = simparams['P_in_plant'].index.to_timestamp()
        results['c'] = simparams['c']
        
        return results
    
    def plot_results(results):
        
        #plt.rcParams['figure.subplot.bottom'] = 0.14
            
        fig1 = plt.figure()#figsize = (160./25.4, 160./25.4))
        ax1 = fig1.add_subplot(311)
        ax2 = fig1.add_subplot(312)
        ax3 = fig1.add_subplot(313)
        
        index = results['timeindex']
        
        #just to be clear that none of the
        # grid purchased electricity should be going to the inverter, and only to storage
        
        # bar1 = ax1.bar(rrp.index, P_ts_out, simparams['dt']/24, -P_ts_out)[0]
        # bar2 = ax1.bar(rrp.index, P_ts_in_panels, simparams['dt']/24, 0)[0]
        # bar3 = ax1.bar(rrp.index, P_ts_in_grid, simparams['dt']/24, P_ts_in_panels)[0]
        
        # fig1.legend([bar1, bar2, bar3], 
        #            ['P_ts_out', 'P_ts_in_panels', 'P_ts_in_grid'], loc = 9, ncol = 5)
        
        line1 = ax1.plot(index, -results['P_ts_out'], label = 'P_ts_out')[0]
        line2 = ax1.plot(index, results['P_ts_in_panels_cur'], label = 'P_ts_in_panels_cur')[0]
        line3 = ax1.plot(index, results['P_ts_in_panels_vol'], label = 'P_ts_in_panels_vol')[0]
        line4 = ax1.plot(index, results['P_ts_in_grid'], label = 'P_ts_in_grid')[0]
        line5 = ax1.plot(index, results['P_out_pass'], label = 'P_out_pass')[0] 
        
        fig1.legend([line1, line2, line3, line4, line5], 
                ['P_ts_out', 'P_ts_in_panels_cur', 'P_ts_in_panels_vol', 
                 'P_ts_in_grid', 'P_out_pass'], loc = 9, ncol = 5)
        
        ax1.grid(True)
        ax1.set_xlabel('')
        ax1.set_ylabel('Power (MW-e)')
        ax1.axis([index[0], index[-1], -60, 60])
        
        ax2.plot(index, results['Q'][:-1])
        ax2.grid(True)
        ax2.set_xlabel('')
        ax2.set_ylabel('Q (MWh-th)')
        ax2.set_xlim([index[0], index[-1]])
        
        ax3.plot(index, results['c'])
        ax3.axis([index[0], index[-1],0,200])
        ax3.grid(True)
        ax3.set_xlabel('Date')
        ax3.set_ylabel('Spot Price\n(\$/MWh)')
        
        plt.show()
        
        
    def optimise_os(simparams):
        
        print(os) 
        
        results = calc_S_perfect_foresight(simparams['plant'], simparams['state'], 
                                           simparams['year'], 
                                           simparams['eta_rh'] * simparams['eta_pc'], 
                                           c_pb * yearfrac, c_ts * yearfrac, 
                                           c_rh * yearfrac, 
                                           c_length = int(17520 * yearfrac),
                                           no_solar = no_solar, os = os, Q_ts_max = None, 
                                           P_ts_in_max = None, P_ts_out_max = None, 
                                           write = False)
        
        C_PV = c_PV * PSF_plant.power_AC * os / 1e3 * yearfrac
        profit = results['obj'] - [C_PV, 0][no_solar]
        
        print("Storage hours =", results['Q_ts_max'] * results['eta_pc'] / results['P_ts_out_max'])
        print("Heater power in =", results['P_ts_in_max'])
        print("Power cycle size =", results['P_ts_out_max'])
        print("Objective =", results['obj'])
        print(["PV_plant_cost = %.2f" %-C_PV,''][no_solar])
        print('profit =', profit)
        print('')
        
        return -profit
    
    def sensitivity(varname, varrange, results):
        """
    'varname' is the name of the variable over which the senstivity analysis 
    will be performed. The change in profit will be measured over 'varrange'.
    
    'varname': {'os', 'Q_ts_max', 'P_ts_in_max', 'P_ts_out_max'}
    """
        profitlist = []    
    
        os = [results['os']]
        Q_ts_max = [results['Q_ts_max']]
        P_ts_in_max = [results['P_ts_in_max']]
        P_ts_out_max = [results['P_ts_out_max']]
    
        if varname == 'os': os = varrange
        if varname == 'Q_ts_max': Q_ts_max = varrange
        if varname == 'P_ts_in_max': P_ts_in_max = varrange
        if varname == 'P_ts_out_max': P_ts_out_max = varrange
    
        kwargs_dict = [dict({'os' : i, 'Q_ts_max': j, 'P_ts_in_max': k, 'P_ts_out_max': l}) \
             for i in os for j in Q_ts_max for k in P_ts_in_max for l in P_ts_out_max]
     
        
        for kwargs in kwargs_dict:
            
            print(kwargs)
            print('')
            
            results = calc_S_perfect_foresight(PSF_plant, state, year, RTE, 
                                        c_pb * yearfrac, c_ts * yearfrac, 
                                        c_rh * yearfrac, c_length = int(17520 * yearfrac),
                                        no_solar = no_solar, write = False, **kwargs)
            
            results['C_PV'] = c_PV * PSF_plant.power_AC * kwargs['os'] / 1e3 * yearfrac
            results['profit'] = results['obj'] - [results['C_PV'], 0][no_solar]
            results['os'] = best_os['x']
            
            print("Storage hours =", results['Q_ts_max'] * results['eta_pc'] / results['P_ts_out_max'])
            print("Heater power in =", results['P_ts_in_max'])
            print("Power cycle size =", results['P_ts_out_max'])
            print("Objective =", results['obj'])
            print(["PV_plant_cost = %.2f" %-results['C_PV'],''][no_solar])
            print('profit =', results['profit'])
            print('')
            
            profitlist.append(results['profit'])
            
        return(array(profitlist)) 

    def _resample_DC_time_series(self):
    ##This might need testing to see whether the resulting DC time series has
    #resampling the DC time series from the PV plant to be every half hour.
    #This function might be able to be made more general in case there
    #are other time series that need to redone
        period_range = pd.period_range(start = self.Time.start_time, end = self.Time.end_time, 
                                 freq = 'H')[:-1]
        
        self.P_in_plant = pd.Series(self.Plant.DC, index = period_range)
        self.P_in_plant = self.P_in_plant.resample('%iT' %int(self.Time.dt*60)).pad()       

class Inverter():
    def __init__(self, eta_inv):
        self.eta_inv = eta_inv

class Market():
    def __init__(self, market):
        "Market can be straight arbitrage, fcas etc."
        ##still need to set this up so that it gets the prices for a given
        #market. 'market' variable does nothing at the moment. 
        self.market = market
    
    def load_rrp(start_time, end_time, region):
        """
        start_time: time stamp for the start of the interval being simulated
        end_time: time stamp for the end of the interval being simulated
        region: state name on the NEM one of ['QLD', 'TAS', 'VIC', 'SA', 'NSW']
        """
        start_stamp = pd.Timestamp(start_time)
        end_stamp = pd.Timestamp(end_time)
        
        db = 'spot_price.db'
        table = 'actual_price'
        cols = ['state', 'date_time', 'price']
        price_spot = sm.get_data(cols, table, db)
        
        price_spot.columns = ['region', 'date_time', 'spot_price'] # define the data columns 
        price_spot['date_time'] = pd.to_datetime(price_spot['date_time'])
        data = price_spot[(price_spot['region'] == region) & 
                          (price_spot['date_time'] >= start_stamp) & 
                          (price_spot['date_time'] < end_stamp)]
        
               
        return data.set_index('date_time')['spot_price']

class PV_plant:
    def __init__(self, name):
        
        db_dir = datadir + 'plants%s' %connector
        db = 'plants.db'
        #load dataframe with plant params
        var_df = dict(sm.get_table(db, 'PV', db_dir).loc[name])   
        
        self.name = name            #short name of plant
        self._load_variables(**var_df)
        self._calc_power_DC()
        
    def _load_variables(self, region, latitude, longitude, power_AC, elev, tilt,
                       azimuth, oversize, design, losses, eta_inv, C_pv_cap,
                       C_pv_OM):

        self.region = region        #Australian state in which the plant is located
        self.latitude = latitude    #[degrees] site coordinate
        self.longitude = longitude  #[degrees] site coordinate
        self.elev = elev            #[m] elevation of sites
        self.power_AC = power_AC    #[kW] design output AC
        self.tilt = tilt            #[rad] panel tilt
        self.azimuth = azimuth      #[rad] panel azimuth angle  
        self.oversize = oversize    #[kW/m^2] (derived from values for PSF, assumed for others)
        self.design = design        #[kW/m^2] (assumed)
        self.losses = losses
        self.eta_inv = eta_inv      #[-] The efficiency of the inverter
        self.C_pv_cap = C_pv_cap
        self.C_pv_OM = C_pv_OM


    def _calc_power_DC(self):
        self.power_DC = self.power_AC * self.oversize / self.eta_inv  #[kW] design output DC
        self._get_PVWatts()
        

    def _get_PVWatts(self):
        api_key = "7C11bMIUFytK1Y0S06jj8ByfUCDGqlEYYARFq7fF"
        website = "https://developer.nrel.gov/api/pvwatts/v6.json?"
        
        req = website + "api_key=%s&" %api_key
        req = req + "lat=%s&" %self.latitude
        req = req + "lon=%s&" %self.longitude
        req = req + "system_capacity=%s&" %self.power_DC
        req = req + "azimuth=%s&" %np.rad2deg(self.azimuth)
        req = req + "tilt=%s&" %np.rad2deg(self.tilt)
        req = req + "dc_ac_ratio=%s&" %self.oversize
        req = req + "array_type=2&"     #single-axis tracking
        req = req + "module_type=0&"
        req = req + "losses=%s&" %self.losses 
        req = req + "dataset=intl&"
        req = req + "timeframe=hourly&"
        req = req + "inv_eff=%s" %(self.eta_inv * 100)
        
        self.request = requests.get(req)
        
        self.data_dict = self.request.json()
        
        self.outputs = self.data_dict['outputs']
        
        self.DNI = np.array(self.outputs['dn']) / 1000      #[kW/m^2]
        self.DC = np.array(self.outputs['dc']) / 1e6       #[MW]
        self.AC = np.array(self.outputs['ac']) / 1e6       #[MW]
        self._calc_eta_inv_rt()
        self._calc_DC_to_AC()
        self._calc_DC_curtailed()
        

    def _calc_eta_inv_rt(self):
        P_DC0 = self.power_AC / self.eta_inv   #[kW]
        zeta = self.DC / P_DC0                           #[-]
        zeta[zeta > 1] = 1
        self.eta_inv_rt = self.eta_inv / 0.9637 * \
            (-0.0162 * zeta - 0.0059 / zeta + 0.9858)
    
    def _calc_DC_to_AC(self):
        #Here it's calculated how much DC power was required to generate
        #the AC power that the plant produced.
        self.DC_to_AC = self.AC / self.eta_inv_rt
    
    def _calc_DC_curtailed(self):   
        
        self.DC_curtailed = self.DC - self.DC_to_AC
        #Next, clean up small errors between the DC_to_AC that I calc'd and that 
        #from the AC and DC time series returned by PVWatts when there is no
        #curtailment taking place. Some error will still be present during
        #times of curtailment.
        self.DC_curtailed[self.DC_curtailed < 0] = 0 
        

    def set_oversize(self, oversize):
        self.oversize = oversize
        self._calc_power_DC()

        
class Time():
    def __init__(self, start_time, end_time, dt = 0.5):
        self.start_time = pd.Timestamp(start_time)
        self.end_time = pd.Timestamp(end_time)
        self.dt = dt
        self.interval = pd.Timedelta(self.end_time - self.start_time).days * 24
        self.N = int(self.interval / dt)
        #The following the year fraction to the nearest day assuming no leap year
        #This is much less than the error in the prices it is being used to 
        #calculate. ##Can be fixed later.
        self.yearfrac = self.interval / (365 * 24)

class PowerCycle():
    #C_pc comes from turchi-techreport-2013 power block cost of 
    #$1000/kW-e generation capacity plus $350/KW-e balance of plant 
    #(steam generator)
    def __init__(self, P_pc_in_max, eta_pc = 0.4, C_pc = 1350e3, ):
        self.P_pc_in_max = P_pc_in_max
        self.eta_pc = eta_pc
        self.C_pc = C_pc

class Financials():
    def __init__(self, lifetime = 20, period = 1./12, acc = 0.0725, 
                 USD2AUD = 1.5):
        "All input prices are in USD"
        self.USD2AUD = USD2AUD     
        self.periods = int(lifetime / period)
        self.pcc = 1-(1-acc)**period     #periodic cost of capital
 
    
    def calc_annual_cost(self, cost):
        """
    This function calculates the annual cost which is appropriate as the
    cost coefficient to be used in the the MiniZinc optimisations.
        
    Cost: total cost of the system over the lifetime ($)
    lifetime: expected lifetime of the system (years)
    period: compounding period (years)
    acc: annual cost of capital as fraction between 0 and 1.
    """
        periodic_cost = cost * (self.pcc * (1 + self.pcc)**self.periods) / \
            (((1 + self.pcc)**self.periods) - 1)
        annual_cost = periodic_cost / self.period
    
        return annual_cost   


class Tank():
    def __init__(self, P_ts_in_max = 50, Q_ts_max = 500., Q_ts_init_frac = 0.5, 
                 Q_ts_min_frac = 0.1, C_ts = None, C_rh_single = None, 
                 eta_rh = 1., V_rh = 240, I = 25, eta_ts = None):
        ##This need to be set up to take tank size OR cost of tank and
        #heat size OR max power into tank. The respective former options allow
        #the simulation to find an optimum size for each while the latter
        #fixed these sizes. 
        #Typical values for the costs of the thermal storage and the
        #resistance heater can be C_ts = 30e3, C_rh = 16.7e3

        ##Not sure it's worth including a loss but can try later
        #self.eta_ts = 0.99**(1./24)
       
        self.P_ts_in_max = P_ts_in_max
        self.Q_ts_max = Q_ts_max
        self.Q_ts_init_frac = Q_ts_init_frac
        self.Q_ts_min_frac = Q_ts_min_frac
        self.C_ts = C_ts
        self.eta_rh = eta_rh
        self.opt_rh = False
        self.init_fail = False
        
        if Q_ts_max == None:
            if C_rh_single != None:
                self.C_rh = self.calc_rh_cost(C_rh_single, V_rh, I)
                self.opt_rh = True
                print('Optimising tank size according to price')
            else: 
                print('Tank size or cost must be set')
                self.init_fail = True
        else: 
            print('Using fixed tank size')
            
    def calc_rh_cost(self):    
        #7/3/2020
        #This product: https://www.alibaba.com/product-detail/10kw-Immersion-Heater-400v_62345866250.html?spm=a2700.details.deiletai6.9.6998U3UAU3UABf
        #costs 100 USD per elements. At 240V, this translates to 6kW, or 167 units per
        #megawatt, which is $16,700 per megawatt. Annualised assuming 30 year plant
        #lifetime and 7.25% cost of money with monthly repayments, this equals about: 
        #25 amps of current calculated from P=VI with V = 400 and P = 10kW 
 
        P_rh_single = self.I * self.V_rh  
        
        N_rh = ceil(1e6 / P_rh_single)          #number per megawatt capacitiy
        self.C_rh = self.C_rh_single * N_rh         #$ per megawatt
    
    

    



def calc_S_perfect_foresight(plant, State, Year, RTE, c_pb, c_ts, 
                             c_rh, os = 1.24, c_length = None, P_ts_in_max = None, 
                             Q_ts_max = None, P_ts_out_max = None, 
                             no_solar = False, write = True, 
                             db='storage_value_PV_perfect',
                             table='storage_value'):
    """This function calculates the storage value with perfect foresight.
        write: specifies whether to write the data into the database or not.
        db: the database to write
        table: the table in the db to write
    """

    plant.set_oversize(os)
    plantsim = PlantPerf_PVW(plant)  
    plantsim.resample_DC_time_series(Year)

    cols_recording = ['plant_name', 'state', 'date_time', 'rte', 'os', 'Q_ts_max',
                      'c_pb', 'c_ts', 'P_ts_in_max', 'P_ts_out', 'P_ts_out_max',
                      'P_ts_in_panels_cur', 'P_ts_in_panels_vol', 
                      'P_ts_in_grid', 'P_out_pass', 'P_out_grid', 'RRP']
    
    idx = ['plant_name', 'state', 'date_time', 'rte', 'os', 'c_pb', 'c_ts']
      
    print(plant.name, State, Year, float(RTE)/100, os)
      
    c = gd.load_rrp_cal(Year, State)
    time_stamp_to_record = c.index.astype(str)
    # c[c>Cap]=Cap
    if c_length == None:
        length = len(c)
    else: length = c_length    
    c = c.tolist()[:length]
    
    if no_solar: 
        plantsim.P_in_plant = pd.Series(zeros(len(plantsim.P_in_plant)),
                                         index = plantsim.P_in_plant.index)
    
    simparams = load_simparams(c, plantsim.P_in_plant)      
    simparams['c'] = c
    simparams['N'] = len(c)
    simparams['eta_rh'] = 1.
    simparams['eta_pc'] = float(RTE)/100
    simparams['c_pb'] = c_pb
    simparams['c_ts'] = c_ts
    simparams['c_rh'] = c_rh
    simparams['P_ts_in_max'] = P_ts_in_max   
    simparams['Q_ts_max'] = Q_ts_max
    simparams['P_ts_out_max'] = P_ts_out_max
    
    #DO IT!
    results = optimise(simparams)
            
    # register the generated data into the database
    if write:
          n = len(time_stamp_to_record)
          DATA = pd.DataFrame({'plant_name': plant.name,
                               'state': State,
                               'date_time':time_stamp_to_record,
                               'rte': RTE,
                               'os': os, 
                               'c_pb': c_pb,
                               'c_ts': c_ts,
                               'P_ts_in_max': results['P_ts_in_max'],
                               'P_ts_out_max': results['P_ts_out_max'],
                               'Q_ts_max': results['Q_ts_max'],
                               'P_ts_out': results['P_ts_out'][0:n],
                               'P_ts_in_panels_cur': results['P_ts_in_panels_cur'][0:n], 
                               'P_ts_in_panels_vol': results['P_ts_in_panels_vol'][0:n],
                               'P_ts_in_grid': results['P_ts_in_grid'][0:n],
                               'P_out_pass': results['P_out_pass'][0:n], 
                               'P_out_grid': results['P_out_grid'][0:n],
                               'RRP': c[0:n]
                               })
          DB=db+'_%s.db'%(plant.name)
          sm.create_table(table, DB, cols_recording,
                          create_unique_idx=True, idx_cols=idx)
          sm.replace_into_db(DATA, DB, table, cols_recording)
          
    return(results)


def optimise(simparams):
    """simparams is a dictionary containing the storage
    parameters for the dzn file."""    
    curdir =  optdir + "arbitrage%s" %['/', '\\'][windows]
    mzdir = ['/home/jeff/local/software/MiniZinc/bin/',
             'C:\\Program Files\\minizinc\\'][windows]
    
    make_dzn_file_PV_plant_SH_PB(**simparams)

    output = str(check_output([mzdir + 'minizinc', "--soln-sep", '""', 
                               "--search-complete-msg", '""', "--solver", 
                               "COIN-BC", curdir + "arbitrage_PV_plant_SH_PB.mzn", 
                               curdir + "arbitrage_PV_plant_SH_PB.dzn"]))

    output = output.replace("""\\r\\n""\\r\\n""\\r\\n\'""", '')
    output = output.replace("b\'[", '')
    output = output.replace('[', '')
    output = output.replace(']', '')
    
    if not windows: output = output.replace('\\n""\\n""\\n\'','')

    P_in_grid, P_out_pass, P_inv_in, P_out_grid, Q, Q_ts_max, P_ts_out_max, P_ts_in_max = \
        output.split(';')
    
    P_in_grid = array(P_in_grid.split(',')).astype(float)
    P_out_pass = array(P_out_pass.split(',')).astype(float)
    P_inv_in = array(P_inv_in.split(',')).astype(float)
    P_out_grid = array(P_out_grid.split(',')).astype(float)
    Q = array(Q.split(',')).astype(float)
    obj = sum((P_out_grid-P_in_grid) * simparams['c']) * simparams['dt']
   
    
    results = {}
    results['Q_ts_max'] = float(Q_ts_max)
    results['P_ts_in_max'] = float(P_ts_in_max)
    results['P_ts_out_max'] = float(P_ts_out_max)
    results['Q'] = Q
    results['P_in_plant'] = array(simparams['P_in_plant'])
    results['P_in_grid'] = P_in_grid
    results['P_out_grid'] = P_out_grid
    results['P_out_pass'] = P_out_pass
    results['P_inv_in'] = P_inv_in
    results['P_inv_out'] = P_inv_in * simparams['eta_inv']
    results['obj'] = obj
    results['eta_pc'] = simparams['eta_pc']
    results['eta_inv'] = simparams['eta_inv']
    results['eta_rh'] = simparams['eta_rh']
    results['eta_ts'] = simparams['eta_ts']    #possibly not implemented
    
        #calculate the equivalent electrical energy leaving the thermal battery
    results['P_ts_out'] = results['P_out_grid'] - results['P_inv_in'] * simparams['eta_inv']  #(MW-e)
    
    #calculate the electrical energy being used to charge the thermal battery
    results['P_ts_in'] = results['P_in_plant'] + results['P_in_grid'] - \
        results['P_out_pass'] - results['P_inv_in']
        
    results['P_ts_in_panels'] = results['P_ts_in'] - results['P_in_grid']
    
    P_ts_in_panels_cur = results['P_in_plant'] - simparams['P_inv_in_max'] - \
        results['P_out_pass']
    P_ts_in_panels_cur[P_ts_in_panels_cur < 0] = 0
    results['P_ts_in_panels_cur'] = P_ts_in_panels_cur
    
    results['P_ts_in_panels_vol'] = results['P_ts_in_panels'] - P_ts_in_panels_cur
    results['P_ts_in_grid'] = results['P_in_grid'] 
    results['timeindex'] = simparams['P_in_plant'].index.to_timestamp()
    results['c'] = simparams['c']
    
    return results

def plot_results(results):
    
    #plt.rcParams['figure.subplot.bottom'] = 0.14
        
    fig1 = plt.figure()#figsize = (160./25.4, 160./25.4))
    ax1 = fig1.add_subplot(311)
    ax2 = fig1.add_subplot(312)
    ax3 = fig1.add_subplot(313)
    
    index = results['timeindex']
    
    #just to be clear that none of the
    # grid purchased electricity should be going to the inverter, and only to storage
    
    # bar1 = ax1.bar(rrp.index, P_ts_out, simparams['dt']/24, -P_ts_out)[0]
    # bar2 = ax1.bar(rrp.index, P_ts_in_panels, simparams['dt']/24, 0)[0]
    # bar3 = ax1.bar(rrp.index, P_ts_in_grid, simparams['dt']/24, P_ts_in_panels)[0]
    
    # fig1.legend([bar1, bar2, bar3], 
    #            ['P_ts_out', 'P_ts_in_panels', 'P_ts_in_grid'], loc = 9, ncol = 5)
    
    line1 = ax1.plot(index, -results['P_ts_out'], label = 'P_ts_out')[0]
    line2 = ax1.plot(index, results['P_ts_in_panels_cur'], label = 'P_ts_in_panels_cur')[0]
    line3 = ax1.plot(index, results['P_ts_in_panels_vol'], label = 'P_ts_in_panels_vol')[0]
    line4 = ax1.plot(index, results['P_ts_in_grid'], label = 'P_ts_in_grid')[0]
    line5 = ax1.plot(index, results['P_out_pass'], label = 'P_out_pass')[0] 
    
    fig1.legend([line1, line2, line3, line4, line5], 
            ['P_ts_out', 'P_ts_in_panels_cur', 'P_ts_in_panels_vol', 
             'P_ts_in_grid', 'P_out_pass'], loc = 9, ncol = 5)
    
    ax1.grid(True)
    ax1.set_xlabel('')
    ax1.set_ylabel('Power (MW-e)')
    ax1.axis([index[0], index[-1], -60, 60])
    
    ax2.plot(index, results['Q'][:-1])
    ax2.grid(True)
    ax2.set_xlabel('')
    ax2.set_ylabel('Q (MWh-th)')
    ax2.set_xlim([index[0], index[-1]])
    
    ax3.plot(index, results['c'])
    ax3.axis([index[0], index[-1],0,200])
    ax3.grid(True)
    ax3.set_xlabel('Date')
    ax3.set_ylabel('Spot Price\n(\$/MWh)')
    
    plt.show()
    
    
def optimise_os(simparams):
    
    print(os) 
    
    results = calc_S_perfect_foresight(simparams['plant'], simparams['state'], 
                                       simparams['year'], 
                                       simparams['eta_rh'] * simparams['eta_pc'], 
                                       c_pb * yearfrac, c_ts * yearfrac, 
                                       c_rh * yearfrac, 
                                       c_length = int(17520 * yearfrac),
                                       no_solar = no_solar, os = os, Q_ts_max = None, 
                                       P_ts_in_max = None, P_ts_out_max = None, 
                                       write = False)
    
    C_PV = c_PV * PSF_plant.power_AC * os / 1e3 * yearfrac
    profit = results['obj'] - [C_PV, 0][no_solar]
    
    print("Storage hours =", results['Q_ts_max'] * results['eta_pc'] / results['P_ts_out_max'])
    print("Heater power in =", results['P_ts_in_max'])
    print("Power cycle size =", results['P_ts_out_max'])
    print("Objective =", results['obj'])
    print(["PV_plant_cost = %.2f" %-C_PV,''][no_solar])
    print('profit =', profit)
    print('')
    
    return -profit

def sensitivity(varname, varrange, results):
    """
'varname' is the name of the variable over which the senstivity analysis 
will be performed. The change in profit will be measured over 'varrange'.

'varname': {'os', 'Q_ts_max', 'P_ts_in_max', 'P_ts_out_max'}
"""
    profitlist = []    

    os = [results['os']]
    Q_ts_max = [results['Q_ts_max']]
    P_ts_in_max = [results['P_ts_in_max']]
    P_ts_out_max = [results['P_ts_out_max']]

    if varname == 'os': os = varrange
    if varname == 'Q_ts_max': Q_ts_max = varrange
    if varname == 'P_ts_in_max': P_ts_in_max = varrange
    if varname == 'P_ts_out_max': P_ts_out_max = varrange

    kwargs_dict = [dict({'os' : i, 'Q_ts_max': j, 'P_ts_in_max': k, 'P_ts_out_max': l}) \
         for i in os for j in Q_ts_max for k in P_ts_in_max for l in P_ts_out_max]
 
    
    for kwargs in kwargs_dict:
        
        print(kwargs)
        print('')
        
        results = calc_S_perfect_foresight(PSF_plant, state, year, RTE, 
                                    c_pb * yearfrac, c_ts * yearfrac, 
                                    c_rh * yearfrac, c_length = int(17520 * yearfrac),
                                    no_solar = no_solar, write = False, **kwargs)
        
        results['C_PV'] = c_PV * PSF_plant.power_AC * kwargs['os'] / 1e3 * yearfrac
        results['profit'] = results['obj'] - [results['C_PV'], 0][no_solar]
        results['os'] = best_os['x']
        
        print("Storage hours =", results['Q_ts_max'] * results['eta_pc'] / results['P_ts_out_max'])
        print("Heater power in =", results['P_ts_in_max'])
        print("Power cycle size =", results['P_ts_out_max'])
        print("Objective =", results['obj'])
        print(["PV_plant_cost = %.2f" %-results['C_PV'],''][no_solar])
        print('profit =', results['profit'])
        print('')
        
        profitlist.append(results['profit'])
        
    return(array(profitlist))